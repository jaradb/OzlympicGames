package games;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;

import persons.Athlete;
import persons.Official;

public abstract class Game {

	// The max and min participants, as a constant.
	static final public int MAX_PARTICIPANTS = 8;
	static final public int MIN_PARTICIPANTS = 4;
	
	

	private String uniqueGameID;
	private ArrayList<Athlete> competitors;
	private ArrayList<Athlete> competitorsSortedByTimes;
	private Official referee;
	private String gameDate;

	private Athlete firstPlaceWinner, secondPlaceWinner, thirdPlaceWinner;

	// A multi-line string reported what happened in this game.
	private String gameResult;

	// Number of times the game was run.
	private int roundNumber = 0;

	public Game(String uniqueGameID) {
		this.uniqueGameID = uniqueGameID;
		competitors = new ArrayList<Athlete>();
		gameDate = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(new Date());
	}

	public int getRoundNumber() {
		return roundNumber;
	}

	public ArrayList<Athlete> getCompetitors() {
		return competitors;
	}

	public void setCompetitors(ArrayList<Athlete> competitors) {
		this.competitors = competitors;
	}

	public void clearCompetitorList() {
		competitors.clear();
	}

	public String getUniqueGameID() {
		return uniqueGameID;
	}

	public void setUniqueGameID(String uniqueGameID) {
		this.uniqueGameID = uniqueGameID;
	}

	public String getGameResult() {
		return gameResult;
	}
	
	public String getGameDate()
	{
		return gameDate;
	}

	abstract public String getGameName();

	abstract public Class<?> getAltheteClassTypeForGame();

	public void runGame() {
		// Increment the number of times this game was run.
		roundNumber++;

		int competitorsCount = getCompetitors().size();
		if (competitorsCount < Game.MIN_PARTICIPANTS) {
			gameResult = getGameName() + " (round " + roundNumber
					+ ") cancelled due to lack of participants. Game requires at least 4 participants to be played, only "
					+ competitorsCount + " participant(s) were scheduled.\n";

			// Cancel out if not enough players are present
			return;
		}

		if (competitorsCount > Game.MAX_PARTICIPANTS) {
			gameResult = getGameName() + " (round " + roundNumber
					+ ") cancelled due to excess participants. Game cannot exceed 8 participants, " + competitorsCount
					+ " participants were scheduled.\n";
			// Cancel out if too many players are present
			return;
		}

		// Create a list to store all the competitors times, which will be
		// generated by compete()
		ArrayList<Float> competitorsTimes = new ArrayList<Float>();

		for (Athlete athlete : getCompetitors()) {
			float time = athlete.compete();
			athlete.setLastTimeRecorded(time);
			competitorsTimes.add(time);
		}
		
		//getCompetitors().sort(null);
		
		getCompetitors().sort(new Comparator<Athlete>() {

			@Override
			public int compare(Athlete athlete1, Athlete athlete2) {

				if (athlete1.getLastTimeRecorded() > athlete2.getLastTimeRecorded())
					return 1;
				if (athlete1.getLastTimeRecorded() < athlete2.getLastTimeRecorded())
					return -1;

				return 0;
			}
		});
		
		firstPlaceWinner = getCompetitors().get(0);
		secondPlaceWinner = getCompetitors().get(1);
		thirdPlaceWinner = getCompetitors().get(2);

		/*
		// Figure out who came first.
		int firstPlaceListIndex = getBestTimeIndex(competitors, competitorsTimes);
		firstPlaceWinner = getCompetitors().get(firstPlaceListIndex);

		// Now remove the first place winner and check again to see who came
		// second
		getCompetitors().remove(firstPlaceListIndex);
		competitorsTimes.remove(firstPlaceListIndex);

		int secondPlaceListIndex = getBestTimeIndex(competitors, competitorsTimes);
		secondPlaceWinner = getCompetitors().get(secondPlaceListIndex);

		// Now remove the second place winner and check one last time to see who
		// came third.
		getCompetitors().remove(secondPlaceListIndex);
		competitorsTimes.remove(secondPlaceListIndex);

		int thirdPlaceListIndex = getBestTimeIndex(competitors, competitorsTimes);
		thirdPlaceWinner = getCompetitors().get(thirdPlaceListIndex);

		// Game has finished, clear out the competitors list
		clearCompetitorList();

		// The referee returns the game result and assigns the three first
		// places with appropriate points
		gameResult = referee.confirmGameResults(getGameName(), roundNumber, firstPlaceWinner, secondPlaceWinner,
				thirdPlaceWinner);
				*/
	}

	// Figure out the best time in the list given. This method assumes the two
	// lists are equal size
	// as the indices need to match. For example, the 5th time in the list is
	// attached to the 5th athlete.
	private int getBestTimeIndex(ArrayList<Athlete> competitors, ArrayList<Float> competitorTimes) {
		float bestTime = Float.MAX_VALUE;
		int bestTimeIndex = 0;

		for (int i = 0; i < competitorTimes.size(); i++) {
			if (competitorTimes.get(i) < bestTime) {
				bestTime = competitorTimes.get(i);
				bestTimeIndex = i;
			}
		}

		return bestTimeIndex;
	}

	public Athlete getWinner() {
		return firstPlaceWinner;
	}
	
	public Athlete getSecondPlace() {
		return secondPlaceWinner;
	}
	
	public Athlete getThirdPlace() {
		return thirdPlaceWinner;
	}

	public Official getReferee() {
		return referee;
	}

	public void setReferee(Official referee) {
		this.referee = referee;
	}

}
